below is a test case using assert_spun()

the prompt is for one more line of grammar that adds the ending
punct after the stream of tokens in the sentence. The stopping punct. tx!

      assert_spun(boat.tokens[1000..1020], &.value).should eq [
        "A victim to one\r\n" + "hundred and seven fatal maladies.",
        "A",
        " ",
        "victim",
        " ",
        "to",
        " ",
        "one",
        "\r\n",
        "\r\n",
        "hundred",
        " ",
        "and",
        " ",
        "seven",
        " ",
        "fatal",
        " ",
        "maladies",
        # TODO  where's the period?
        "Useful prescriptions.",
        "Useful prescriptions."]

here's the fully vetted PEG grammar in Crystal-pegmatite that pegs our grammar correctly. Please only advise the line to update in it. tx!

class BookGrammar
  # Use the DSL.define block to build the pattern tree
  MAIN = Pegmatite::DSL.define do
    low = range('a', 'z') # Basic atoms
    upp = range('A', 'Z')
    digit = range('0', '9')
    blank = l(" ")
    collapsed = blank.repeat(1).named(:punct) # This captures a run of 1 or more spaces as a single token & saves cognitive room by identifying as a punct

    # Define CRLF (carriage return + linefeed) as a single unit
    cr = l("\r") # carriage return alone
    lf = l("\n") # linefeed alone
    crlf = (cr >> lf).named(:punct)

    # Individual line breaks
    brk = (crlf | cr | lf).named(:punct)
    white = collapsed | l("\t") | brk
    dot = l('.')
    bang = l('!')
    query = l('?')

    # Punctuation and Catch-all
    terminal = dot | bang | query
    punct = terminal | l(',') | l(':') | l(';') | l('-') | l('"') | l('\'')
    punct = punct.named(:punct)
    unknown = any # Non-judgmental fallback

    # Rules
    word = (upp | low | digit).repeat(1).named(:word)
    sentence_start = (upp >> (low | upp | digit).repeat).named(:word)

    # A sentence is a Cap, then anything that isn't terminal punct, then terminal punct
    sentence = (sentence_start >> (~terminal >> (word | punct | white | unknown)).repeat >> terminal).named(:sentence)
    paragraph = (sentence.repeat(1) >> brk.maybe).named(:paragraph)

    # Top level entry point
    (paragraph | sentence | white | word | punct | unknown).repeat.then_eof
  end
end
